- 함수형 컴포넌트: 함수 형태로 만들어진 컴포넌트\*\*
  ex. const ExComponent = (props) ⇒ {}, function ExComponent(props) {}

  (1) 간결하고 직관적인 코드 작성이 가능, 상태 관리와 생명주기 기능을 손쉽게 구현
  ⇒ useState, useEffect와 같은 \*Hook(훅)\*\*을 사용하면, 클래스형 컴포넌트에서 볼 수 있는 복잡한 생명주기 메서드를 사용하지 않고도 컴포넌트의 상태를 관리하고, 부수 효과를 처리할 수 있기 때문

  (2) 상태 로직을 재사용하기 용이
  ⇒ 커스텀 훅을 통해 공통 로직을 캡슐화하고, 이를 여러 컴포넌트에서 재사용

  (3) 함수형 컴포넌트는 테스트하기가 더 쉽다.
  ⇒ 순수 함수의 형태로 컴포넌트를 작성 → 외부 상태에 의존하지 않고 독립적으로 테스트

- 클래스형 컴포넌트: 클래스 형태로 만들어진 컴포넌트\*\*
  ex. class ExComponent extends React.Component {constructor(props) {}}

  (1) 생명주기 메서드를 통한 세밀한 컴포넌트 제어
  ⇒ componentDidMount, componentDidUpdate와 같은 생명주기 메서드를 사용하여 컴포넌트의 생성부터 업데이트, 소멸까지의 과정을 정교하게 관리

  (2) this 키워드를 통해 인스턴스 변수에 접근할 수 있으며, 이를 통해 컴포넌트 내부의 상태를 보다 쉽게 관리
  ⇒ this.state와 this.setState를 사용하여 컴포넌트의 상태를 직접 관리 → 명확성을 제공, 상속을 통해 코드를 재사용 할 수 있다.

💡 리액트 팀은 함수형 컴포넌트와 훅을 사용하는 것을 권장! → 앞으로 리액트의 미래 방향성을 반영\*\* (아래 이어서 내용 설명)

\*Hook: React 버전 \*\*16.8\*\*부터 React 요소로 새로 추가

배경 )\*\*

(1) 함수형 컴포넌트의 상태 관리와 생명주기 기능의 부재\*\*(상태 관리나 생명주기 기능은 클래스형 컴포넌트에서만 사용할 수 있었음)

(2) 컴포넌트 간 상태 로직의 재사용 문제\(\*고차 컴포넌트나 \*렌더 프롭스 패턴을 사용하여 로직을 재사용하는 방식은 코드의 복잡성을 증가)

\*고차 컴포넌트\*\*: 고차 컴포넌트는 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수

\*렌더 프롭스 패턴\*\*: props의 형태가 jsx

변화 )\*\*

(1) 함수형 프로그래밍의 채택 →\ React 개발자들은 \*함수형 프로그래밍 \*패러다임을 더 쉽게 채택할 수 있게 됨

\*함수형 프로그래밍: 대입문을 사용하지 않는 프로그래밍, 작은 문제를 해결하기 위한 함수\*\*를 작성

\*패러다임: 프로그래밍의 관점을 갖게 하고 코드를 어떻게 작성할 지 결정하는 역할을 함

(2) 코드의 단순화 및 가독성 향상 →클래스형 컴포넌트에서 볼 수 있는 복잡한 생명주기 메서드(componentDidMount, componentDidUpdate)를 사용하지 않고도, Hooks를 통해 간결하고 직관적인 코드 작성이 가능해짐

💡 함수형 컴포넌트와 Hook(훅)을 적극적으로 활용하는 것이 더 나은 코드 유지보수성과 재사용성을 제공하며, 최신 리액트 기능을 최대한 활용할 수 있는 방법이며, 이를 통해 React 개발자들은 보다 직관적이고 간결한 코드를 작성할 수 있으며, 복잡한 상태 관리와 생명주기 로직을 보다 쉽게 구현할 수 있음
→ \*앞으로의 리액트 개발에서는 함수형 컴포넌트와 Hook(훅)을 중심으로 한 패러다임이 더욱 중요해질 것이다.\*\*
